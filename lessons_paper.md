# lessons

## 介绍

* 无服务计算渐渐成为云计算主要范式，它具有前瞻性的简化平台开发的潜力，能沟帮助开发者从繁琐的冗余操作任务脱离。 
* 无服务平台负责管理用户已经打包上传至平台的应用，这让开发者更专注于平台的逻辑执行无需关注底层的资源管理和部署。不止如此，随着用户需求量变化，无服务平台还会负责管理底层架构资源管理和伸缩部署用户的应用。这一特性受到了工业界和学术界的极大拥护。但是无服务平台暂时只适用于一些特定场景——无状态和并行执行
* 但是无服务器计算的使用仅限于少数表现为无状态和并行执行的应用场景，而且如果重新构建现有代码库去适应无服务计算需求，这会带来很多成本投入。
* 为了避免这种繁杂的重构原代码库，尽量减少代码修改的迁移策略可以作为一个新的研究方向，而本文将4个微服务平台迁移到无服务平台 (`Apache open Whisk`)，这个实验过程中的经验和结果观测能更好的帮助推动这一研究方向进展，其中有许多关于在迁移过程中减少修改代码和实际性能考虑的指导。这些工作内容能帮助提高无服务计算的高可用性和无服务平台的适用性。
* 迁移中的挑战
  * 迁移过程中尽可能减少代码修改
  * 迁移后的平台的性能表现应该与迁移前保持相似
* 无服务平台
  * `Apache OpenWhisk`
* 微服务平台
  * `Overleaf` (基于云的LaTex编辑平台)
  * `Social Network` (社交网络平台)
  * `LAB Insurance Sales Portal` (电子商务平台)
  * `Robot Shop` (电子商务平台)
  
## 背景和动机

### 微服务平台

* 一个典型的微服务应用由许多长期运行的微服务（多达数百甚至数千个）组成，涵盖计算、通信和存储功能。这些微服务是松耦合的，并通过定义好的`API`相互通信，因此每个微服务可以单独开发和运行。
* 每个微服务通常作为一个服务器运行。这种类型的部署排除了只有在需要时才执行服务，并可能导致应用开发者过度配置资源以满足工作负载的要求。这种过度配置导致基础设施运营商的资源利用率低，而应用开发者的开发成本高。此外，尽管微服务架构简化了每个微服务组件的开发和运行方式，但它要求开发者仔细监测和管理资源（如容器、虚拟机），以适当地扩展每个微服务，这使得为经常变化的工作负载提供服务具有挑战性。

### 无服务平台

* 无服务器计算范式的目的是让开发者不再管理资源，快速扩展到不同的工作负载，并通过现收现付的定价模式提供成本效益。无服务器计算最流行的实现方式是 "功能即服务" (`FaaS`)。
* 在`FaaS`平台中，开发者将他们的应用逻辑写成一组无状态函数。每个请求被派发到一个函数或一个函数序列，这将导致一个函数实例被安排在一个行动容器内运行，处理请求并产生输出。在函数执行完成后，其状态被销毁或通过存储或信息传递系统外部化；因此，释放出的资源可用于其他用途。这些机制结合在一起，使无服务器功能的执行通常是短暂的，并能在需要时对基础设施资源进行灵活、精细的调度和扩展，以满足不同的工作负载。这种灵活性反过来又为基础设施运营商带来了资源效率，为开发者带来了成本效率。
* 然而，无服务器功能的无状态性质在复杂的有状态应用和FaaS平台之间造成了一种根本性的矛盾。
* 为了充分利用无服务器计算，现有复杂应用的开发者必须重新架构他们的应用，这样做成本很高，而且有些临时性，因此最好是最大限度地重用现有代码库。因此，有一种原则性的方法可以将现有的应用程序迁移到无服务器平台上，并使代码的改动最小，性能（如延迟）相当，这是非常有意义的。

## 迁移的工作内容

* 被迁移的平台由12-26个微服务组件组成，其中包括应用逻辑组件，以及通常用于通信（如`Kafka`和`RabbitMQ`）、保持应用状态（如`Redis`和`MongoDB`）或监控应用状态（如`Zipkin`和`Jaeger`）的现成的软件组件。为了尽量减少对原始应用架构的改变，不会迁移这些现成的组件；或者，这些组件可以用无服务器平台提供的对应组件来代替（例如，`AWS S3`用于保持应用状态）。此外，由于无服务器功能是短暂的，不能直接在网络上寻址，如果微服务组件以双向流的方式与其他实体互动，例如通过`websocket`或流式`RPC`，我们就保持其不变。
  
###  Overleaf

`Overleaf`是一个实时协作的`LaTeX`编辑器。除了现成的组件（如`NginX`、`MongoDB`和`Redis`），它还有12个应用逻辑微服务，都是用`JavaScript`编写的在`Node.js`运行。这些微服务使用`RESTful APIs`和`Redis Pub/Sub`通道相互通信，`MongoDB`被用于数据存储。`Overleaf`利用`Express`框架，它允许微服务中的内部服务模块暴露给其他微服务。

#### 迁移。

* 如表2所示，我们为`Overleaf`引入了1.2%的代码行变化。首先，12个应用逻辑组件中的8个是无状态的，并通过`RESTful APIs`进行通信，使它们的迁移变得简单明了：我们为每个组件增加了一个包装函数，作为`OpenWhisk`所需的入口。这个包装器负责在调用时将参数转发给原始的`Express`处理程序。

* 此外，还有4个有状态的微服务组件。
	* #1 `Web`微服务作为发送请求到下游微服务的调度器，作为请求认证器，读取本地存储的凭证以验证请求，也作为文件上传/下载的代理服务器。
		* 迁移修改：论文中
	* #2 `clsi`微服务编译`LaTeX`文件并在本地存储输出。这个本地存储作为一个文件服务器，用于文件的检索。
	* #3 `filestore`微服务负责提供Overleaf文件。
	* #4 实时微服务向客户暴露可寻址的网络接口，接受传入的连接并通过连接与客户进行交互。

#### 经验与指导——状态管理

在这4个组件中，我们对web和clsi组件进行了修改。简而言之，对于web，我们分离了它的认证模块，将认证相关的凭证持久化在Redis中，并保留了原始微服务中的文件代理服务器模块（见第4.3节）。对于clsi，我们对38行代码进行了修改，将生成的文件存储在filetore中。因此，我们可以将web和clsi迁移到无服务器中，而将filestore和real-time仍然作为微服务保留，以尽量减少代码的变化，并遵守原有的架构。
3.2 社交网络
Social Network[12]是一个基于DeathStarBench的在线社交网络应用，DeathStarBench曾被用作云微服务的基准套件[11]。这个应用使用Apache Thrift[30]来实现用C++和Lua编写的微服务之间的RPC通信。迁移。Social Net-work中的所有应用逻辑微服务都是无状态的，我们可以将它们全部迁移。我们面临的关键挑战是，Apache OpenWhisk的功能是通过HTTP请求调用的，输入的是JSON编码的数据，而社交网络的RPC代码使用的是低级别的套接字API。因此，我们必须将其原始的RPC通信转换为HTTP通信，并实现额外的JSON序列化/反序列化功能。为了协助这一转换，我们开发了一个半自动的脚本，大约有700行Python代码。关于请求路由逻辑，我们绕过了原来的RPC监听器（见第4.2节）。LAB保险销售门户（缩写为LAB）[18]是一个使用Micronaut微服务框架[21]的电子商务应用。它的微服务是用Java和Kotlin编写的，并依赖于Micronaut库。服务间的通信通过RESTful APIs或Apache Kafka消息代理[3]进行。
迁移。有6个无状态的应用逻辑微副组件。这些组件最初与RESTful APIs和Kafka通信，因此我们做了必要的修改，使它们的通信适应OpenWhisk所需的特征，并完全删除了Kafka（见第4.1节）。对于剩下的4个有状态的组件，我们注意到它们每个都运行一个本地的H2内存数据库[9]来管理状态。我们将这些H2数据库统一为一个新的有状态组件，这一改变使我们能够将这4个组件也迁移到无服务器中。它使用了几种流行的编程语言，包括Node.js、Java、PHP、Python和Golang，以及Express、Flask和Spark等网络框架。它的微服务通过RESTful APIs和RabbitMQ相互通信。迁移。它的所有应用逻辑微服务都是无状态的，它们的迁移与之前描述的Overleaf应用程序的迁移相似。我们保留了原来的监听器来转发请求，并增加了请求编码/解码的步骤。我们的大部分努力都集中于在此应用程序中使用的不同语言和框架中进行这种转换。此外，我们删除了RabbitMQ组件，该组件最初用于异步触发一些用户服务（即调度），因为其功能已经被OpenWhisk所支持。此外，我们删除了RabbitMQ组件，该组件最初用于异步触发一些用户服务（即调度），因为其功能已经被OpenWhisk所支持。综上所述，虽然Robot Shop的代码库是最小的，但代码修改的比例（35.1%）是所有四个应用程序迁移中最高的



最后，我们确定是否以及如何将剩余的应用逻辑微服务组件调整为无服务器函数，并特别关注这些处理同步通信、状态管理和其他一些微服务（第4节的指南）。

	