# lessons

## 介绍

* 无服务计算渐渐成为云计算主要范式，它具有前瞻性的简化平台开发的潜力，能沟帮助开发者从繁琐的冗余操作任务脱离。 
* 无服务平台负责管理用户已经打包上传至平台的应用，这让开发者更专注于平台的逻辑执行无需关注底层的资源管理和部署。不止如此，随着用户需求量变化，无服务平台还会负责管理底层架构资源管理和伸缩部署用户的应用。这一特性受到了工业界和学术界的极大拥护。但是无服务平台暂时只适用于一些特定场景——无状态和并行执行
* 但是无服务器计算的使用仅限于少数表现为无状态和并行执行的应用场景，而且如果重新构建现有代码库去适应无服务计算需求，这会带来很多成本投入。
* 为了避免这种繁杂的重构原代码库，尽量减少代码修改的迁移策略可以作为一个新的研究方向，而本文将4个微服务平台迁移到无服务平台 (`Apache open Whisk`)，这个实验过程中的经验和结果观测能更好的帮助推动这一研究方向进展，其中有许多关于在迁移过程中减少修改代码和实际性能考虑的指导。这些工作内容能帮助提高无服务计算的高可用性和无服务平台的适用性。
* 迁移中的挑战
  * 迁移过程中尽可能减少代码修改
  * 迁移后的平台的性能表现应该与迁移前保持相似
## 背景和动机

### 微服务平台

* 一个典型的微服务应用由许多长期运行的微服务（多达数百甚至数千个）组成，涵盖计算、通信和存储功能。这些微服务是松耦合的，并通过定义好的`API`相互通信，因此每个微服务可以单独开发和运行。
* 每个微服务通常作为一个服务器运行。这种类型的部署排除了只有在需要时才执行服务，并可能导致应用开发者过度配置资源以满足工作负载的要求。这种过度配置导致基础设施运营商的资源利用率低，而应用开发者的开发成本高。此外，尽管微服务架构简化了每个微服务组件的开发和运行方式，但它要求开发者仔细监测和管理资源（如容器、虚拟机），以适当地扩展每个微服务，这使得为经常变化的工作负载提供服务具有挑战性。

### 无服务平台

* 无服务器计算范式的目的是让开发者不再管理资源，快速扩展到不同的工作负载，并通过现收现付的定价模式提供成本效益。无服务器计算最流行的实现方式是 "功能即服务" (`FaaS`)。
* 在`FaaS`平台中，开发者将他们的应用逻辑写成一组无状态函数。每个请求被派发到一个函数或一个函数序列，这将导致一个函数实例被安排在一个行动容器内运行，处理请求并产生输出。在函数执行完成后，其状态被销毁或通过存储或信息传递系统外部化；因此，释放出的资源可用于其他用途。这些机制结合在一起，使无服务器功能的执行通常是短暂的，并能在需要时对基础设施资源进行灵活、精细的调度和扩展，以满足不同的工作负载。这种灵活性反过来又为基础设施运营商带来了资源效率，为开发者带来了成本效率。
* 然而，无服务器功能的无状态性质在复杂的有状态应用和FaaS平台之间造成了一种根本性的矛盾。
* 为了充分利用无服务器计算，现有复杂应用的开发者必须重新架构他们的应用，这样做成本很高，而且有些临时性，因此最好是最大限度地重用现有代码库。因此，有一种原则性的方法可以将现有的应用程序迁移到无服务器平台上，并使代码的改动最小，性能（如延迟）相当，这是非常有意义的。

## 迁移的工作内容

* 无服务平台
  * `Apache OpenWhisk`
* 微服务平台
  * `Overleaf` (基于云的LaTex编辑平台)
  * `Social Network` (社交网络平台)
  * `LAB Insurance Sales Portal` (电子商务平台)
  * `Robot Shop` (电子商务平台)

* 被迁移的平台由12-26个微服务组件组成，其中包括应用逻辑组件，以及通常用于通信（如`Kafka`和`RabbitMQ`）、保持应用状态（如`Redis`和`MongoDB`）或监控应用状态（如`Zipkin`和`Jaeger`）的现成的软件组件。为了尽量减少对原始应用架构的改变，不会迁移这些现成的组件；或者，这些组件可以用无服务器平台提供的对应组件来代替（例如，`AWS S3`用于保持应用状态）。此外，由于无服务器功能是短暂的，不能直接在网络上寻址，如果微服务组件以双向流的方式与其他实体互动，例如通过`websocket`或流式`RPC`，我们就保持其不变。
###  Overleaf

`Overleaf`是一个实时协作的`LaTeX`编辑器。除了现成的组件（如`NginX`、`MongoDB`和`Redis`），它还有12个应用逻辑微服务，都是用`JavaScript`编写的在`Node.js`运行。这些微服务使用`RESTful APIs`和`Redis Pub/Sub`通道相互通信，`MongoDB`被用于数据存储。`Overleaf`利用`Express`框架，它允许微服务中的内部服务模块暴露给其他微服务。

#### 迁移

* 如表2所示，我们为`Overleaf`引入了1.2%的代码行变化。首先，12个应用逻辑组件中的8个是无状态的，并通过`RESTful APIs`进行通信，使它们的迁移变得简单明了：我们为每个组件增加了一个包装函数，作为`OpenWhisk`所需的入口。这个包装器负责在调用时将参数转发给原始的`Express`处理程序。

* 此外，还有4个有状态的微服务组件。
	* #1 `Web`微服务作为发送请求到下游微服务的调度器，作为请求认证器，读取本地存储的凭证以验证请求，也作为文件上传/下载的代理服务器。
		* 迁移修改：论文中分离了它的认证模块，将认证相关的凭证持久化在`Redis`中，并保留了原始微服务中的文件代理服务器模块。
	* #2 `clsi`微服务编译`LaTeX`文件并在本地存储输出。这个本地存储作为一个文件服务器，用于文件的检索。
	  * 迁移修改：修改了38行代码，将生成的文件存储在`filetore`中
	* #3 `filestore`微服务负责提供Overleaf文件。（不做修改）
	* #4 实时微服务向客户暴露可寻址的网络接口，接受传入的连接并通过连接与客户进行交互。（不做修改）

#### 经验与指导——状态管理

* 无服务器函数通常是无状态的，而且生命周期短的，目的是为了使它们易于管理和扩展。对同一个无服务器函数的多个请求可能会被引导到不同的函数实例上执行，因此，一次执行产生的状态可能无法被下一次执行所访问。然而，这种方法使许多微服务应用所需的状态管理变得复杂。为了在同一功能的多个实例之间或在多个功能之间共享状态，一种常见的方法是将状态外部化到一些中介件（例如`MongoDB`、`Redis`或`AWS S3`等存储系统），以便共享状态。如果应用程序使用现成的存储组件（如`MongoDB`），可以简单地保留这些组件以尽量减少代码更改，或者修改应用程序以使用无服务器平台提供的存储服务（如`AWS S3`），所以该文将那些归类为现有的组件不再修改。
* 如果状态被存储在本地的定制微服务组件内，我们必须在外部化之前手动识别应用程序的状态。例如，在`Overleaf`中有两种类型的本地状态。一种是用于`Web`微服务中认证的`csrf` `tokens`。另一个是`clsi`服务中的编译文件，迁移后存储在`filestore`中。这些数据在我们迁移后被存储在`Redis`中。


### Social Network

`Social Network`是一个基于`DeathStarBench`的在线社交网络应用，`DeathStarBench`曾被用作云微服务的基准套件。这个应用使用`Apache Thrift`来实现用`C++`和`Lua`编写的微服务之间的`RPC`通信。

####  迁移

`Social Net-work`中的所有应用逻辑微服务都是无状态的，这里可以将它们全部迁移。本论文面临的关键挑战是，`Apache OpenWhisk`的功能是通过`HTTP`请求调用的，输入的是`JSON`编码的数据，而社交网络的RPC代码使用的是低级别的套接字`API`。因此，我们必须将其原始的`RPC`通信转换为`HTTP`通信，并实现额外的`JSON`序列化/反序列化功能。为了协助这一转换，本文开发了一个半自动的脚本，大约有700行`Python`代码。关于请求路由逻辑，我们绕过了原来的RPC监听器。

#### 经验指导——监听（Listening）和路由（Routing）

无论在通信中选择什么样的同步性，相互作用的微服务组件必须监听新的请求，并将它们路由到相关的内部处理程序。通过`RESTful APIs`和`RPCs`，微服务通常暴露一个网络端口，并通过该端口接受请求。通过消息代理（如`Kafka`、`RabbitMQ`、`Redis` `Pub/Sub`），微服务订阅了一个主题或通道，并等待传入的请求。

在无服务器计算的背景下，这种用于接收消息的脚手架代码变得没有必要，因为功能之间的消息交换是由无服务器平台处理的。在以最小的代码改动为目标的迁移工作中，需要对这种输入进行适当的转换，以便将请求分派给相应的处理程序。有两种方法可以采取。

##### 保留监听

这种方法会在无服务器函数中保留微服务组件的原始监听器。为了处理请求，需要重新编写一些附着（glue）代码，以便将无服务器平台上传入的`HTTP`请求转换为微服务组件所接受的请求格式。例如，如果最初的微服务组件有一个`RPC`服务器，那么附着（glue）代码就必须在无服务器功能中把`HTTP`请求转换成`RPC`。这种方法可以极大地减少迁移的工作量。例如，在`Overleaf`中，我们只需要写66行`JavaScript`附着代码来包装现有的监听器，然后将其应用到10个微服务组件中。一个潜在的缺点是附着代码所带来的额外延迟。

##### 绕过监听

这种方法将删除或绕过原来的监听器。它的效率更高，但它需要前人的努力，为每种类型的请求找到并调用适当的内部处理程序。在基于RPC的微服务中，RPC存根和处理程序代码的解耦使迁移变得相当直接。相比之下，在使用REST API的微服务中，处理程序和监听器的代码更加紧密耦合，例如，由于底层框架（例如，`JavaScript`的`Express`和`Python`的`Flask`）。这种迁移需要更多的努力和改变，使其更加繁琐和容易出错。例如，使用`Express`框架编写的`Overleaf`的`Spelling`组件需要修改大约150行代码，尽管该微服务本身只由800行代码组成。对于像`web`这样由大约4万行代码组成的大型微服务，这种修改需要更多的修改。

### LAB Insurance Sales Portal

`LAB`是一个使用`Micronaut`微服务框架的电子商务应用。它的微服务是用`Java`和`Kotlin`编写的，并依赖于`Micronaut`库。服务间的通信通过`RESTful APIs`或`Apache Kafka`消息代理进行。

#### 迁移

`LAB`有6个无状态的应用逻辑微副组件。这些组件最初与`RESTful APIs`和`Kafka`通信，因此我们做了必要的修改，使它们的**通信**适应`OpenWhisk`所需的特征，并完全删除了`Kafka`。对于剩下的4个有状态的组件，它们每个都运行一个本地的H2内存数据库来管理状态, 所以将这些H2数据库统一为一个新的有状态组件，这一改变使我们能够将这4个组件也迁移到无服务器中。

#### 经验指导——通信

* 微服务组件通过明确定义的接口相互通信。根据应用的需要，这种通信可以同步进行，也可以异步进行。在异步通信中，消息的发送者并不等待来自接收者的响应。这方面的例子包括通过消息中介和异步RPC的通信。在无服务器计算的背景下，通过阻塞的无服务器功能调用来应用同步通信，但这可能会导致效率低下和重复计费。因此，由于通信模式的转换，通过同步通道进行通信的微服务需要更多的改变才能从无服务器计算中获益。该论文把这些探索留给未来的工作。
* 无服务器功能之间的通信通常发生在异步通道中，迁移由异步通道交换消息的微服务组件（如消息代理）可以通过各种方式进行修改。
  * 发布时调用
    * 由于无服务器函数只有在有请求时才会被触发，所以不能简单地将作为消息接收者的微服务组件（以订阅者模式工作）用于有请求时执行的无服务器函数中。因此，发送者（即发布者）必须异步地调用无服务器功能，这样才能接收和处理消息。
  * 调用而不发布。
    * 发送者也可以用请求消息调用接收者函数（见图2c）。这种方法的优点是消除了发布和接收消息代理所带来的开销。此外，它使消息代理变得多余，因此可以删除它以简化应用程序的架构。另一方面，消息代理提供的功能，如消息排序或多用户并行支持，将丢失并必须以其他方式提供。例如，发送者可能需要调用多个订阅函数来实现并行性。

### Robot Shop

`Robot Shop`使用了几种流行的编程语言，包括`Node.js`、`Java`、`PHP`、`Python`和`Golang`，以及`Express`、`Flask`和`Spark`等网络框架。它的微服务通过`RESTful APIs`和`RabbitMQ`相互通信。

#### 迁移

它的所有应用逻辑微服务都是无状态的，它们的迁移与之前描述的`Overleaf`应用程序的迁移相似。保留了原来的监听器来转发请求，并增加了请求编码/解码的步骤。我们的大部分努力都集中于在此应用程序中使用的不同语言和框架中进行这种转换。

* 删除了`RabbitMQ`组件，该组件最初用于异步触发一些用户服务（即调度），因为其功能已经被`OpenWhisk`所支持。
* 删除了`RabbitMQ`组件，该组件最初用于异步触发一些用户服务（即调度），因为其功能已经被`OpenWhisk`所支持。

综上所述，虽然`Robot Shop`的代码库是最小的，但代码修改的比例（35.1%）是所有四个应用程序迁移中最高的。

## 实验评估

我们报告了我们对三个应用的初步评估。Overleaf、Social Network和Robot Shop1，并比较了原始的微服务架构和我们的迁移版本。我们首先分解了每个应用程序中一个任务的请求处理（即Overleaf中的 "编译"、Social Network中的 "StorePost "和Robot Shop中的 "提交订单"）。之后，我们增加Overleaf的 "编译 "任务和Robot Shop的 "提交订单 "任务的负载，以评估OpenWhisk提供的可扩展性，并报告吞吐量和延迟值。我们使用Locust[19]进行负载生成。
我们的实验是在一个有40个2.2GHz vCPUs、40GB RAM和250GB SSD的虚拟机（VM）中进行的。这个虚拟机承载了OpenWhisk的安装，有一个con- troller，一个invoker和一个无限的容器池大小，以及没有被迁移的微服务组件。这些组件在独立的容器中运行，没有再源限制。所有的无服务器功能都在OpenWhisk中以256MB的内存部署。为了与始终部署的微服务组件进行公平的比较，我们确保我们的OpenWhisk功能是在温暖的容器中运行。这种设置是合理的，我们的决定有如下理由。首先，在稳定的工作负载下，功能容器将是温暖的，以更好地服务请求。其次，减少冷启动和调用延迟是一个活跃的研究课题[2, 15, 22]，与本工作正交。





​	